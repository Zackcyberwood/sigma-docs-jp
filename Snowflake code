【キャンペーンデータ】
-- ステップ1：テーブルを一度まっさらに作り直す
CREATE OR REPLACE TABLE TBL_CAMPAIGNS (
    CAMPAIGN_ID       VARCHAR(10),
    CAMPAIGN_NAME     VARCHAR(100),
    START_DATE        DATE,
    END_DATE          DATE,
    CAMPAIGN_TYPE     VARCHAR(30),
    CAMPAIGN_COST     NUMBER(10, 0)
);

-- ステップ2：作り直したテーブルに、2025年上半期だけのデータを120件生成・挿入する
INSERT INTO TBL_CAMPAIGNS (
    CAMPAIGN_ID, CAMPAIGN_NAME, START_DATE, END_DATE, CAMPAIGN_TYPE, CAMPAIGN_COST
)
WITH BASE_DATA AS (
    SELECT
        SEQ8() as id,
        -- 開始日を「2025年上半期」の範囲に限定（最終日が6/30になるよう、5月中旬までの開始日にする）
        DATEADD(day, UNIFORM(0, 150, RANDOM()), '2025-01-01') AS GENERATED_START_DATE,
        CASE 
            WHEN UNIFORM(1, 10, RANDOM()) <= 2 THEN 'タイアップ・コラボ型'
            WHEN UNIFORM(1, 10, RANDOM()) <= 4 THEN '新商品ローンチ型'
            WHEN UNIFORM(1, 10, RANDOM()) <= 7 THEN '購入者限定応募型'
            ELSE '季節イベント型'
        END AS CAMPAIGN_TYPE
    FROM TABLE(GENERATOR(ROWCOUNT => 120))
)
SELECT
    'CAMP' || LPAD(b.id, 5, '0'),
    '2025年 上半期 ' || 
    CASE
        WHEN b.CAMPAIGN_TYPE = 'タイアップ・コラボ型' THEN (SELECT NAME FROM (VALUES ('人気アニメ「グルログ」'), ('有名パティシエ「辻口氏」')) T(NAME) ORDER BY RANDOM() LIMIT 1) || ' コラボ'
        ELSE (SELECT NAME FROM (VALUES ('焦がしバターのフィナンシェ'), ('石臼挽き抹茶のテリーヌ')) T(NAME) ORDER BY RANDOM() LIMIT 1) || ' 発売記念'
    END,
    b.GENERATED_START_DATE,
    
    -- ▼▼▼ 終了日が6/30を超えないように、LEAST関数で制御 ▼▼▼
    LEAST(
        DATEADD(day, UNIFORM(14, 28, RANDOM()), b.GENERATED_START_DATE),
        '2025-06-30'
    ),
    
    b.CAMPAIGN_TYPE,
    UNIFORM(50000, 200000, RANDOM())
FROM BASE_DATA b;

【TBL_ANSWER】
-- ステップ1：購入履歴テーブルを一度まっさらにする
CREATE OR REPLACE TABLE TBL_PURCHASES (
    PURCHASE_ID       VARCHAR(10),
    CUSTOMER_ID       VARCHAR(10),
    PURCHASE_DATE     TIMESTAMP_NTZ,
    PRODUCT_CATEGORY  VARCHAR(50),
    PURCHASE_AMOUNT   NUMBER(10, 0)
);

-- ステップ2：シンプルなロジックでデータを挿入する
INSERT INTO TBL_PURCHASES (
    PURCHASE_ID,
    CUSTOMER_ID,
    PURCHASE_DATE,
    PRODUCT_CATEGORY,
    PURCHASE_AMOUNT
)
SELECT
    'PURC' || LPAD(SEQ8(), 5, '0'),
    
    -- 1番から1000番までの顧客IDをランダムに割り振る
    'CUST' || LPAD(UNIFORM(1, 1000, RANDOM()), 5, '0'),

    -- 購入日時は、2025年上半期のランダムな日時
    DATEADD(second, UNIFORM(0, 15552000, RANDOM()), '2025-01-01 00:00:00'),

    -- 商品カテゴリをランダムに割り振る
    (SELECT val FROM (VALUES ('スナック菓子'),('チョコレート'),('焼き菓子'),('ドリンク')) AS T(val) ORDER BY RANDOM() LIMIT 1),
    
    -- 購入金額をランダムに割り振る
    UNIFORM(500, 8000, RANDOM())

FROM
    TABLE(GENERATOR(ROWCOUNT => 400)); -- 400件の購入データを生成MY_HANDSON_DB.PUBLIC.TBL_ANSWERS

【TBL_Purchase】
-- ステップ1：購入履歴テーブルを一度まっさらにする
CREATE OR REPLACE TABLE TBL_PURCHASES (
    PURCHASE_ID       VARCHAR(10),
    CUSTOMER_ID       VARCHAR(10),
    PURCHASE_DATE     TIMESTAMP_NTZ,
    PRODUCT_CATEGORY  VARCHAR(50),
    PURCHASE_AMOUNT   NUMBER(10, 0)
);

-- ステップ2：シンプルなロジックでデータを挿入する
INSERT INTO TBL_PURCHASES (
    PURCHASE_ID,
    CUSTOMER_ID,
    PURCHASE_DATE,
    PRODUCT_CATEGORY,
    PURCHASE_AMOUNT
)
SELECT
    'PURC' || LPAD(SEQ8(), 5, '0'),
    
    -- 1番から1000番までの顧客IDをランダムに割り振る
    'CUST' || LPAD(UNIFORM(1, 1000, RANDOM()), 5, '0'),

    -- 購入日時は、2025年上半期のランダムな日時
    DATEADD(second, UNIFORM(0, 15552000, RANDOM()), '2025-01-01 00:00:00'),

    -- 商品カテゴリをランダムに割り振る
    (SELECT val FROM (VALUES ('スナック菓子'),('チョコレート'),('焼き菓子'),('ドリンク')) AS T(val) ORDER BY RANDOM() LIMIT 1),
    
    -- 購入金額をランダムに割り振る
    UNIFORM(500, 8000, RANDOM())

FROM
    TABLE(GENERATOR(ROWCOUNT => 400)); -- 400件の購入データを生成MY_HANDSON_DB.PUBLIC.TBL_ANSWERS

【TBL_ANSWER】
-- ステップ1：アンケート回答テーブルを一度まっさらにして作り直す
CREATE OR REPLACE TABLE TBL_ANSWERS (
    ANSWER_ID         VARCHAR(30),
    CUSTOMER_ID       VARCHAR(10),
    CAMPAIGN_ID       VARCHAR(10),
    QUESTION_ID       VARCHAR(10),
    ANSWER_TEXT       VARCHAR(500),
    ANSWERED_AT       TIMESTAMP_NTZ
);

-- ステップ2：他のテーブルを一切参照せず、設問に応じたリアルな回答データを挿入する
INSERT INTO TBL_ANSWERS (
    ANSWER_ID, CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT
)
WITH 
-- まず、4200件の回答の元となる、ランダムなIDの組み合わせを生成
BASE AS (
    SELECT
        'CUST' || LPAD(UNIFORM(1, 1000, RANDOM()), 5, '0') as CUSTOMER_ID,
        'CAMP' || LPAD(UNIFORM(1, 120, RANDOM()), 5, '0') as CAMPAIGN_ID,
        'Q' || UNIFORM(1, 6, RANDOM()) as QUESTION_ID
    FROM
        TABLE(GENERATOR(ROWCOUNT => 4200))
)
-- 次に、生成したIDを基に、設問に応じた回答を組み立てる
SELECT
    'ANS_' || b.CUSTOMER_ID || '_' || b.CAMPAIGN_ID || '_' || b.QUESTION_ID,
    b.CUSTOMER_ID,
    b.CAMPAIGN_ID,
    b.QUESTION_ID,
    -- ▼▼▼ 設問ID（QUESTION_ID）に応じて、回答内容をリアルに変動させる ▼▼▼
    CASE
        WHEN b.QUESTION_ID = 'Q1' THEN
            DECODE(MOD(ABS(HASH(b.CUSTOMER_ID)), 3),
                0, 'コラボキャラクターが好きだから',
                1, '新商品に興味があったから',
                'お得な価格だったから')
        WHEN b.QUESTION_ID = 'Q2' THEN
            DECODE(MOD(ABS(HASH(b.CUSTOMER_ID)), 4),
                0, '味の信頼性',
                1, '価格の手頃さ',
                2, 'パッケージのデザイン',
                '新しさ・話題性')
        WHEN b.QUESTION_ID = 'Q3' THEN
            DECODE(MOD(ABS(HASH(b.CUSTOMER_ID)), 5),
                0, 'Instagram',
                1, 'X (旧Twitter)',
                2, 'Web検索',
                3, 'メールマガジン',
                '店頭ポスター')
        WHEN b.QUESTION_ID IN ('Q4', 'Q5') THEN
            CAST(UNIFORM(1, 5, RANDOM()) AS VARCHAR)
        WHEN b.QUESTION_ID = 'Q6' THEN
            DECODE(MOD(ABS(HASH(b.CUSTOMER_ID)), 6),
                0, 'いつも新商品を楽しみにしております。オンラインストアの決済方法を改善してほしいです。',
                1, 'コラボデザインが想像以上に可愛く、つい全種類集めてしまいました。',
                2, '期待して購入しましたが、私には少し甘すぎると感じました。',
                3, 'パッケージが少し開けにくいと感じました。ジッパー付きだと嬉しいです。',
                4, 'Webサイトの応募方法が少し分かりにくかったです。',
                '特になし')
    END,
    -- 回答日時は、2025年上半期のランダムな日時
    DATEADD(second, UNIFORM(0, 15552000, RANDOM()), '2025-01-01 00:00:00')

FROM BASE b;


【Answer　Ver.2】
-- ステップ1：アンケート回答テーブルを一度まっさらにする
CREATE OR REPLACE TABLE TBL_ANSWERS (
    ANSWER_ID         VARCHAR(30),
    CUSTOMER_ID       VARCHAR(10),
    CAMPAIGN_ID       VARCHAR(10),
    QUESTION_ID       VARCHAR(10),
    ANSWER_TEXT       VARCHAR(500),
    ANSWERED_AT       TIMESTAMP_NTZ
);

-- ステップ2：物語と、詳細な回答ロジックを反映したデータを挿入する
INSERT INTO TBL_ANSWERS (
    ANSWER_ID, CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT
)
WITH 
-- まず、4200件の回答の元となる、ランダムなIDの組み合わせと、「隠れ属性」を生成
BASE AS (
    SELECT
        'CUST' || LPAD(UNIFORM(1, 1000, RANDOM()), 5, '0') as CUSTOMER_ID,
        'Q' || UNIFORM(1, 6, RANDOM()) as QUESTION_ID,
        -- 各行に、どの物語を割り振るかの「シナリオID」を生成 (1=3月のコラボ, 2=5月の新商品, 3=その他)
        CASE 
            WHEN UNIFORM(1, 100, RANDOM()) <= 40 THEN 1 
            WHEN UNIFORM(1, 100, RANDOM()) <= 80 THEN 2
            ELSE 3 
        END as scenario_id
    FROM TABLE(GENERATOR(ROWCOUNT => 4200))
)
-- 次に、生成したIDと属性を基に、回答を組み立てる
SELECT
    'ANS_' || SEQ8(),
    b.CUSTOMER_ID,
    -- シナリオIDに応じて、キャンペーンIDと回答日時を意図的に設定
    CASE 
        WHEN b.scenario_id = 1 THEN 'CAMP00003' -- 3月のコラボキャンペーンID (固定)
        WHEN b.scenario_id = 2 THEN 'CAMP00005' -- 5月の新商品キャンペーンID (固定)
        ELSE 'CAMP00001' -- その他のキャンペーンID (固定)
    END,
    b.QUESTION_ID,
    
    -- ▼▼▼ 設問IDと、顧客IDから生成される「隠れ属性」に応じて、詳細な回答内容を生成 ▼▼▼
    CASE
        WHEN b.QUESTION_ID = 'Q1' THEN
            DECODE(MOD(ABS(HASH(b.CUSTOMER_ID)), 3), 0, 'コラボキャラクターが好きだから', 1, '新商品に興味があったから', 'お得な価格だったから')
        WHEN b.QUESTION_ID = 'Q2' THEN
            DECODE(MOD(ABS(HASH(b.CUSTOMER_ID)), 4), 0, '味の信頼性', 1, '価格の手頃さ', 2, 'パッケージのデザイン', '新しさ・話題性')
        WHEN b.QUESTION_ID = 'Q3' THEN
            DECODE(MOD(ABS(HASH(b.CUSTOMER_ID)), 5), 0, 'Instagram', 1, 'X (旧Twitter)', 2, 'Web検索', 3, 'メールマガジン', '店頭ポスター')
        WHEN b.QUESTION_ID IN ('Q4', 'Q5') THEN
            CAST(UNIFORM(1, 5, RANDOM()) AS VARCHAR)
        WHEN b.QUESTION_ID = 'Q6' THEN
            -- 顧客IDのハッシュ値を基に「隠れランク」を擬似的に作り、回答内容を変化させる
            CASE
                WHEN MOD(ABS(HASH(b.CUSTOMER_ID)), 100) < 10 THEN 'いつも新商品を楽しみにしております。オンラインストアの決済で後払い決済が使えるようになると、さらに嬉しいです。' -- 隠れプラチナ (10%)
                WHEN MOD(ABS(HASH(b.CUSTOMER_ID)), 100) < 30 THEN 'コラボデザインが想像以上に可愛く、つい全種類集めてしまいました。' -- 隠れゴールド (20%)
                WHEN MOD(ABS(HASH(b.CUSTOMER_ID)), 100) < 50 THEN '期待して購入しましたが、私には少し甘すぎると感じました。' -- 隠れ不満層 (20%)
                ELSE '特になし' -- その他 (50%)
            END
    END,
    
    -- シナリオIDに応じて、回答日時を意図的に設定
    CASE
        WHEN b.scenario_id = 1 THEN DATEADD('day', UNIFORM(0, 30, RANDOM()), '2025-03-01') -- 3月に回答が集中
        WHEN b.scenario_id = 2 THEN DATEADD('day', UNIFORM(0, 30, RANDOM()), '2025-05-01') -- 5月に回答が集中
        ELSE DATEADD('day', UNIFORM(0, 180, RANDOM()), '2025-01-01') -- その他は上半期に分散
    END
FROM BASE b;

ー会員情報ー

CREATE OR REPLACE TABLE TBL_CUSTOMERS (
    CUSTOMER_ID       VARCHAR(10),
    GENDER            VARCHAR(10),
    AGE_GROUP         VARCHAR(20),
    PREFECTURE        VARCHAR(50),
    CUSTOMER_RANK     VARCHAR(20),
    REGISTRATION_DATE DATE
);

INSERT INTO TBL_CUSTOMERS (
    CUSTOMER_ID, GENDER, AGE_GROUP, PREFECTURE, CUSTOMER_RANK, REGISTRATION_DATE
)
-- まず、700人の「既存顧客」を生成
SELECT
    'CUST' || LPAD(SEQ8(), 5, '0'),
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.48 THEN '男性' ELSE '女性' END,
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.25 THEN '20代' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.55 THEN '30代' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.80 THEN '40代' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.95 THEN '50代' ELSE '60代以上' END,
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.15 THEN '東京都' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.25 THEN '神奈川県' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.33 THEN '大阪府' ELSE 'その他の都道府県' END,
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.10 THEN 'プラチナ' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.35 THEN 'ゴールド' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.70 THEN 'シルバー' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.85 THEN 'ブロンズ' ELSE 'レギュラー' END,
    -- 登録日を2024年12月31日以前に設定
    DATEADD(day, UNIFORM(0, 1095, RANDOM()), '2022-01-01')
FROM
    TABLE(GENERATOR(ROWCOUNT => 700))

UNION ALL

-- 次に、300人の「新規顧客」を生成
SELECT
    'CUST' || LPAD(SEQ8() + 700, 5, '0'), -- IDが重複しないように調整
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.48 THEN '男性' ELSE '女性' END,
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.40 THEN '20代' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.70 THEN '30代' ELSE '40代' END, -- 新規顧客は若年層が多いと仮定
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.30 THEN '東京都' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.50 THEN '神奈川県' ELSE 'その他の都道府県' END,
    'ブロンズ', -- 新規顧客は、最初は全員「ブロンズ」ランクから始まると仮定
    -- 登録日を「2025年上半期」の範囲に限定
    DATEADD(day, UNIFORM(0, 179, RANDOM()), '2025-01-01')
FROM
    TABLE(GENERATOR(ROWCOUNT => 300));

SELECT * FROM TBL_CUSTOMERS LIMIT 1000;

ーキャンペーンデーター
-- ステップ1：テーブルを一度まっさらに作り直す
CREATE OR REPLACE TABLE TBL_CAMPAIGNS (
    CAMPAIGN_ID       VARCHAR(10),
    CAMPAIGN_NAME     VARCHAR(100),
    START_DATE        DATE,
    END_DATE          DATE,
    CAMPAIGN_TYPE     VARCHAR(30),
    CAMPAIGN_COST     NUMBER(10, 0)
    );
    INSERT INTO TBL_CAMPAIGNS (
    CAMPAIGN_ID, CAMPAIGN_NAME, START_DATE, END_DATE, CAMPAIGN_TYPE, CAMPAIGN_COST
)
-- まず、10件のユニークなキャンペーンの「設計図」をWITH句で定義する
WITH CAMPAIGN_DEFINITIONS AS (
    SELECT ROW_NUMBER() OVER (ORDER BY 1) as id, T.*
    FROM (
        VALUES
            -- タイアップ・コラボ型 (3件)
            ('2025上半期 人気アニメ「グルログ」コラボ', 'タイアップ・コラボ型', 180000),
            ('2025上半期 有名パティシエ「辻口氏」コラボ', 'タイアップ・コラボ型', 220000),
            ('2025上半期 ライフスタイル誌「Cafe Life」コラボ', 'タイアップ・コラボ型', 160000),

            -- 新商品ローンチ型 (3件)
            ('2025上半期 新発売「焦がしバターのフィナンシェ」', '新商品ローンチ型', 120000),
            ('2025上半期 新発売「石臼挽き抹茶のテリーヌ」', '新商品ローンチ型', 150000),
            ('2025上半期 新発売「瀬戸内レモンのクラフトソーダ」', '新商品ローンチ型', 110000),

            -- 購入者限定応募型 (2件)
            ('2025上半期 オリジナルペアマグカップ プレゼント', '購入者限定応募型', 70000),
            ('2025上半期 工場見学ツアーご招待', '購入者限定応募型', 90000),

            -- 季節イベント型 (2件)
            ('2025上半期 桜と抹茶のスイーツフェア', '季節イベント型', 100000),
            ('2025上半期 初夏のフルーツドリンクフェア', '季節イベント型', 110000)
    ) AS T(CAMPAIGN_NAME, CAMPAIGN_TYPE, CAMPAIGN_COST)
)
-- 次に、設計図を基に、日付などのランダムな要素を加えて、最終的なデータを生成する
SELECT
    'CAMP' || LPAD(d.id, 5, '0'),
    d.CAMPAIGN_NAME,
    DATEADD(day, UNIFORM(0, 150, RANDOM()), '2025-01-01') AS START_DATE,
    LEAST(DATEADD(day, UNIFORM(14, 28, RANDOM()), START_DATE), '2025-06-30') AS END_DATE,
    d.CAMPAIGN_TYPE,
    d.CAMPAIGN_COST
FROM
    CAMPAIGN_DEFINITIONS d;

-設問表-
-- ステップ1：設問マスターテーブルを一度まっさらにして作り直す
CREATE OR REPLACE TABLE TBL_QUESTIONS (
    QUESTION_ID       VARCHAR(10),
    QUESTION_TEXT     VARCHAR(200),
    QUESTION_TYPE     VARCHAR(30)
);

-- ステップ2：作成したテーブルに、6つの設問データを挿入する
INSERT INTO TBL_QUESTIONS (QUESTION_ID, QUESTION_TEXT, QUESTION_TYPE)
VALUES
    ('Q1', 'このキャンペーンに参加した主な理由は何ですか？', '単一選択'),
    ('Q2', '商品購入時に最も重視する点は何ですか？', '単一選択'),
    ('Q3', 'このキャンペーンをどこで知りましたか？', '単一選択'),
    ('Q4', 'キャンペーンの総合満足度を5段階で評価してください。', '5段階評価'),
    ('Q5', '商品の味や品質の満足度を5段階で評価してください。', '5段階評価'),
    ('Q6', 'ご意見・ご要望があればご自由にお書きください。', '自由回答');

ーアンケート結果ー
-- ステップ1：テーブル（空の箱）を、ANSWER_ID列を「削除」して作り直す
CREATE OR REPLACE TABLE TBL_ANSWERS (
    CUSTOMER_ID       VARCHAR(10),
    CAMPAIGN_ID       VARCHAR(10),
    QUESTION_ID       VARCHAR(10),
    ANSWER_TEXT       VARCHAR(500),
    ANSWERED_AT       TIMESTAMP_NTZ
);
-- ステップ2：単一のINSERT文で、「Q1」の回答データだけを100件挿入する
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- WITH句を使い、まず「誰が、どのキャンペーンに参加したか」の対応表を作成
WITH RESPONDENTS AS (
    SELECT 
        c.CUSTOMER_ID,
        -- 参加キャンペーンに意図的な「偏り」を持たせる
        CASE 
            WHEN MOD(ABS(HASH(c.CUSTOMER_ID)), 100) < 30 THEN 'CAMP00003'
            WHEN MOD(ABS(HASH(c.CUSTOMER_ID)), 100) < 60 THEN 'CAMP00008'
            WHEN MOD(ABS(HASH(c.CUSTOMER_ID)), 100) < 65 THEN 'CAMP00001'
            ELSE (SELECT CAMPAIGN_ID FROM TBL_CAMPAIGNS ORDER BY RANDOM() LIMIT 1)
        END AS CAMPAIGN_ID
    FROM 
        (SELECT CUSTOMER_ID FROM TBL_CUSTOMERS ORDER BY RANDOM() LIMIT 100) c
)
-- 次に、その対応表と、キャンペーンマスターを「JOIN」で結合する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q1',
    -- JOINした結果から、キャンペーン名を安全に取得
    c.CAMPAIGN_NAME,
    -- JOINした結果から、開始日を安全に取得
    c.START_DATE
FROM 
    RESPONDENTS r
JOIN 
    TBL_CAMPAIGNS c ON r.CAMPAIGN_ID = c.CAMPAIGN_ID;

-- Q2の回答を100人分、生成して追記する
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- まず、Q1に答えた全回答者のリストを取得
WITH RESPONDENTS AS (
    SELECT DISTINCT CUSTOMER_ID, CAMPAIGN_ID, ANSWERED_AT 
    FROM TBL_ANSWERS 
    WHERE QUESTION_ID = 'Q1'
)
-- 次に、その回答者リストを基に、Q2の回答を生成する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q2',
    -- 回答の出現確率に、意図的な「偏り」を持たせる
    CASE 
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 35 THEN '新しさ・話題性'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 70 THEN '味の信頼性'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 90 THEN 'パッケージのデザイン'
        ELSE '価格の手頃さ'
    END,
    r.ANSWERED_AT
FROM RESPONDENTS r;

-- Q3の回答を100人分、生成して追記する
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- まず、Q1に答えた全回答者のリストを取得
WITH RESPONDENTS AS (
    SELECT DISTINCT CUSTOMER_ID, CAMPAIGN_ID, ANSWERED_AT 
    FROM TBL_ANSWERS 
    WHERE QUESTION_ID = 'Q1'
)
-- 次に、その回答者リストを基に、Q3の回答を生成する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q3',
    -- ▼▼▼ 回答の出現確率に、意図的な「偏り」を持たせる ▼▼▼
    CASE 
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 45 THEN 'Instagram'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 65 THEN 'X (旧Twitter)'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 85 THEN 'Web検索'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 95 THEN 'メールマガジン'
        ELSE '店頭ポスター'
    END,
    r.ANSWERED_AT
FROM RESPONDENTS r;

SELECT QUESTION_ID, COUNT(*) FROM TBL_ANSWERS GROUP BY 1; 

-- Q4の回答を100人分、生成して追記する
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- まず、Q1に答えた全回答者のリストを取得
WITH RESPONDENTS AS (
    SELECT DISTINCT CUSTOMER_ID, CAMPAIGN_ID, ANSWERED_AT 
    FROM TBL_ANSWERS 
    WHERE QUESTION_ID = 'Q1'
)
-- 次に、その回答者リストを基に、Q4の回答を生成する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q4',
    -- ▼▼▼ 顧客IDのハッシュ値を使い、意図した確率で、コメントの種類を決定 ▼▼▼
    CASE 
        -- 15%は「改善提案」
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 15 THEN 
            DECODE(MOD(ABS(HASH(r.CUSTOMER_ID)), 4),
                0, 'オンラインストアの決済方法を増やしてほしいです。後払い決済があると嬉しいです。',
                1, 'パッケージが少し開けにくいと感じました。ジッパー付きにするなど、改善していただけると嬉しいです。',
                2, 'Webサイトの応募方法が少し分かりにくかったです。もう少しシンプルな手順だと助かります。',
                '人気商品はすぐに売り切れてしまうので、もう少し在庫を増やしてほしいです。')
        -- 15%は「単なる批判・感想」
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 30 THEN
            DECODE(MOD(ABS(HASH(r.CUSTOMER_ID)), 4),
                0, '期待して購入しましたが、私には少し甘すぎると感じました。',
                1, '広告で見たイメージと、実物の色が少し違ったのが残念です。',
                2, '価格がもう少し安いと嬉しいです。',
                '届くまでに少し時間がかかったように思います。')
        -- 残りの70%は「ポジティブな感想」
        ELSE
            DECODE(MOD(ABS(HASH(r.CUSTOMER_ID)), 5),
                0, 'コラボデザインが想像以上に可愛く、つい全種類集めてしまいました。',
                1, '新商品、とても美味しかったです。また購入します。',
                2, 'キャンペーンありがとうございました。',
                3, '友人にもプレゼントしたら、とても喜ばれました。',
                '今後の企画も楽しみにしています！')
    END,
    r.ANSWERED_AT
FROM RESPONDENTS r;

SELECT 
    ANSWER_TEXT,
    COUNT(*) AS comment_count
FROM 
    TBL_ANSWERS
WHERE 
    QUESTION_ID = 'Q4'
GROUP BY 
    ANSWER_TEXT
ORDER BY
    comment_count DESC;

ー購入履歴ー

-- ステップ1：購入履歴テーブルを一度まっさらにする
CREATE OR REPLACE TABLE TBL_PURCHASES (
    PURCHASE_ID       VARCHAR(10),
    CUSTOMER_ID       VARCHAR(10),
    PURCHASE_DATE     TIMESTAMP_NTZ,
    PRODUCT_CATEGORY  VARCHAR(50),
    PURCHASE_AMOUNT   NUMBER(10, 0)
);

-- ステップ2：物語を反映した購入データを挿入する
INSERT INTO TBL_PURCHASES (
    PURCHASE_ID, CUSTOMER_ID, PURCHASE_DATE, PRODUCT_CATEGORY, PURCHASE_AMOUNT
)
WITH
-- まず、アンケート回答者の中から、重複しない「応募者」のリストを作成する
UNIQUE_APPLICANTS AS (
    SELECT DISTINCT
        a.CUSTOMER_ID,
        c.CAMPAIGN_TYPE,
        cust.CUSTOMER_RANK, -- ★顧客ランクを追加
        a.ANSWERED_AT
    FROM TBL_ANSWERS a
    JOIN TBL_CAMPAIGNS c ON a.CAMPAIGN_ID = c.CAMPAIGN_ID
    JOIN TBL_CUSTOMERS cust ON a.CUSTOMER_ID = cust.CUSTOMER_ID -- ★顧客情報を結合
    WHERE a.QUESTION_ID = 'Q1'
),
-- 次に、各キャンペーンタイプの購入者を抽選する
PURCHASING_CUSTOMERS AS (
    SELECT
        *
    FROM (
        SELECT
            *,
            UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) as lottery_ticket,
            CASE
                WHEN CAMPAIGN_TYPE = '新商品ローンチ型' THEN 0.70
                WHEN CAMPAIGN_TYPE = '購入者限定応募型' THEN 0.45
                WHEN CAMPAIGN_TYPE = '季節イベント型'   THEN 0.25
                WHEN CAMPAIGN_TYPE = 'タイアップ・コラボ型' THEN 0.15
                ELSE 0.20
            END as winning_line
        FROM UNIQUE_APPLICANTS
    )
    WHERE lottery_ticket < winning_line
)
-- 最後に、抽選で選ばれた購入者たちの購買データを生成する
SELECT
    'PURC' || LPAD(ROW_NUMBER() OVER (ORDER BY CUSTOMER_ID), 5, '0'),
    CUSTOMER_ID,
    DATEADD(day, UNIFORM(1, 7, RANDOM()), ANSWERED_AT),
    -- ▼▼▼ 商品カテゴリを、キャンペーンタイプに応じて変動させる ▼▼▼
    CASE
        WHEN CAMPAIGN_TYPE = '新商品ローンチ型' THEN '限定コラボ商品'
        WHEN CAMPAIGN_TYPE = '季節イベント型' THEN DECODE(MOD(ABS(HASH(CUSTOMER_ID)), 2), 0, 'チョコレート', '焼き菓子')
        ELSE DECODE(MOD(ABS(HASH(CUSTOMER_ID)), 2), 0, 'スナック菓子', 'ドリンク')
    END,
    -- ▼▼▼ 購入金額を、顧客ランクに応じて変動させる ▼▼▼
    CASE
        WHEN CUSTOMER_RANK = 'プラチナ' THEN UNIFORM(8000, 15000, RANDOM())
        WHEN CUSTOMER_RANK = 'ゴールド' THEN UNIFORM(5000, 9000, RANDOM())
        WHEN CUSTOMER_RANK = 'シルバー' THEN UNIFORM(2000, 6000, RANDOM())
        ELSE UNIFORM(500, 3000, RANDOM())
    END
FROM
    PURCHASING_CUSTOMERS;

ーアンケート結果ー
-- ステップ1：テーブル（空の箱）を、ANSWER_ID列を「削除」して作り直す
CREATE OR REPLACE TABLE TBL_ANSWERS (
    CUSTOMER_ID       VARCHAR(10),
    CAMPAIGN_ID       VARCHAR(10),
    QUESTION_ID       VARCHAR(10),
    ANSWER_TEXT       VARCHAR(500),
    ANSWERED_AT       TIMESTAMP_NTZ
);

-- ステップ2：「Q1（参加キャンペーン）」の回答データだけを100件挿入する
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- WITH句を使い、まず「誰が、どのキャンペーンに参加したか」の対応表を作成
WITH 
-- 部品1: CUST00001からCUST00100までの、100人の回答者を生成
BASE_CUSTOMERS AS (
    SELECT
        'CUST' || LPAD(SEQ8(), 5, '0') as CUSTOMER_ID
    FROM TABLE(GENERATOR(ROWCOUNT => 100))
),
-- 部品2: 回答者と参加キャンペーンを紐付ける
RESPONDENTS AS (
    SELECT
        bc.CUSTOMER_ID,
        -- 顧客IDのハッシュ値を使い、参加キャンペーンに意図的な「偏り」を持たせる
        CASE 
            WHEN MOD(ABS(HASH(bc.CUSTOMER_ID)), 100) < 30 THEN 'CAMP00003' -- 30%はCAMP3に参加
            WHEN MOD(ABS(HASH(bc.CUSTOMER_ID)), 100) < 60 THEN 'CAMP00005' -- 30%はCAMP5に参加
            WHEN MOD(ABS(HASH(bc.CUSTOMER_ID)), 100) < 65 THEN 'CAMP00001' -- 5%はCAMP1に参加
            -- 残りの35%は、10件のキャンペーンの中からランダムに選ばれる
            ELSE 'CAMP' || LPAD(UNIFORM(1, 10, RANDOM()), 5, '0') 
        END AS CAMPAIGN_ID
    FROM BASE_CUSTOMERS bc
)
-- 最後に、その対応表と、キャンペーンマスターを「JOIN」で結合する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q1',
    -- JOINした結果から、キャンペーン名を安全に取得
    c.CAMPAIGN_NAME,
    -- JOINした結果から、開始日を安全に取得
    c.START_DATE
FROM 
    RESPONDENTS r
JOIN 
    TBL_CAMPAIGNS c ON r.CAMPAIGN_ID = c.CAMPAIGN_ID;

-- ステップ3：「Q2（重視点）」の回答データを100件追記する
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- まず、Q1に答えた全回答者のリストを取得
WITH RESPONDENTS AS (
    SELECT DISTINCT CUSTOMER_ID, CAMPAIGN_ID, ANSWERED_AT 
    FROM TBL_ANSWERS 
    WHERE QUESTION_ID = 'Q1'
)
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- まず、Q1に答えた全回答者のリストを、もう一度ここで定義する
WITH RESPONDENTS AS (
    SELECT DISTINCT CUSTOMER_ID, CAMPAIGN_ID, ANSWERED_AT 
    FROM TBL_ANSWERS 
    WHERE QUESTION_ID = 'Q1'
)
-- 次に、その回答者リストを基に、Q2の回答を生成する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q2',
    -- 回答の出現確率に、意図的な「偏り」を持たせる
    CASE 
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 35 THEN '新しさ・話題性'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 70 THEN '味の信頼性'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 90 THEN 'パッケージのデザイン'
        ELSE '価格の手頃さ'
    END,
    r.ANSWERED_AT
FROM RESPONDENTS r;

-- Q3の回答を100人分、生成して追記する
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- まず、Q1に答えた全回答者のリストを取得
WITH RESPONDENTS AS (
    SELECT DISTINCT CUSTOMER_ID, CAMPAIGN_ID, ANSWERED_AT 
    FROM TBL_ANSWERS 
    WHERE QUESTION_ID = 'Q1'
)
-- 次に、その回答者リストを基に、Q3の回答を生成する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q3',
    -- ▼▼▼ 回答の出現確率に、意図的な「偏り」を持たせる ▼▼▼
    CASE 
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 45 THEN 'Instagram'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 65 THEN 'X (旧Twitter)'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 85 THEN 'Web検索'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 95 THEN 'メールマガジン'
        ELSE '店頭ポスター'
    END,
    r.ANSWERED_AT
FROM RESPONDENTS r;

-- Q4の回答を100人分、生成して追記する
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- まず、Q1に答えた全回答者のリストを取得
WITH RESPONDENTS AS (
    SELECT DISTINCT CUSTOMER_ID, CAMPAIGN_ID, ANSWERED_AT 
    FROM TBL_ANSWERS 
    WHERE QUESTION_ID = 'Q1'
)
-- 次に、その回答者リストを基に、Q4の回答を生成する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q4',
    -- ▼▼▼ 顧客IDのハッシュ値を使い、意図した確率で、コメントの種類を決定 ▼▼▼
    CASE 
        -- 15%は「改善提案」
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 15 THEN 
            DECODE(MOD(ABS(HASH(r.CUSTOMER_ID)), 4),
                0, 'オンラインストアの決済方法を増やしてほしいです。後払い決済があると嬉しいです。',
                1, 'パッケージが少し開けにくいと感じました。ジッパー付きにするなど、改善していただけると嬉しいです。',
                2, 'Webサイトの応募方法が少し分かりにくかったです。もう少しシンプルな手順だと助かります。',
                '人気商品はすぐに売り切れてしまうので、もう少し在庫を増やしてほしいです。')
        -- 15%は「単なる批判・感想」
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 30 THEN
            DECODE(MOD(ABS(HASH(r.CUSTOMER_ID)), 4),
                0, '期待して購入しましたが、私には少し甘すぎると感じました。',
                1, '広告で見たイメージと、実物の色が少し違ったのが残念です。',
                2, '価格がもう少し安いと嬉しいです。',
                '届くまでに少し時間がかかったように思います。')
        -- 残りの70%は「ポジティブな感想」
        ELSE
            DECODE(MOD(ABS(HASH(r.CUSTOMER_ID)), 5),
                0, 'コラボデザインが想像以上に可愛く、つい全種類集めてしまいました。',
                1, '新商品、とても美味しかったです。また購入します。',
                2, 'キャンペーンありがとうございました。',
                3, '友人にもプレゼントしたら、とても喜ばれました。',
                '今後の企画も楽しみにしています！')
    END,
    r.ANSWERED_AT
FROM RESPONDENTS r;

ー会員情報ー
-- ステップ1：テーブルを一度まっさらに作り直す
CREATE OR REPLACE TABLE TBL_CUSTOMERS (
    CUSTOMER_ID       VARCHAR(10),
    GENDER            VARCHAR(10),
    AGE_GROUP         VARCHAR(20),
    PREFECTURE        VARCHAR(50),
    CUSTOMER_RANK     VARCHAR(20),
    REGISTRATION_DATE DATE
);

-- ステップ2：作り直したテーブルに、「既存顧客」と「新規顧客」を合わせて100件生成・挿入する
INSERT INTO TBL_CUSTOMERS (
    CUSTOMER_ID, GENDER, AGE_GROUP, PREFECTURE, CUSTOMER_RANK, REGISTRATION_DATE
)
-- まず、70人の「既存顧客」を生成
SELECT
    'CUST' || LPAD(SEQ8(), 5, '0'),
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.48 THEN '男性' ELSE '女性' END,
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.25 THEN '20代' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.55 THEN '30代' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.80 THEN '40代' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.95 THEN '50代' ELSE '60代以上' END,
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.15 THEN '東京都' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.25 THEN '神奈川県' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.33 THEN '大阪府' ELSE 'その他の都道府県' END,
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.10 THEN 'プラチナ' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.35 THEN 'ゴールド' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.70 THEN 'シルバー' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.85 THEN 'ブロンズ' ELSE 'レギュラー' END,
    -- 登録日を2024年12月31日以前に設定
    DATEADD(day, UNIFORM(0, 1095, RANDOM()), '2022-01-01')
FROM
    TABLE(GENERATOR(ROWCOUNT => 70))

UNION ALL

-- 次に、30人の「新規顧客」を生成
SELECT
    'CUST' || LPAD(SEQ8() + 70, 5, '0'), -- IDが重複しないように調整
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.48 THEN '男性' ELSE '女性' END,
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.40 THEN '20代' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.70 THEN '30代' ELSE '40代' END, -- 新規顧客は若年層が多いと仮定
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.30 THEN '東京都' WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.50 THEN '神奈川県' ELSE 'その他の都道府県' END,
    'ブロンズ', -- 新規顧客は、最初は全員「ブロンズ」ランクから始まると仮定
    -- 登録日を「2025年上半期」の範囲に限定
    DATEADD(day, UNIFORM(0, 179, RANDOM()), '2025-01-01')
FROM
    TABLE(GENERATOR(ROWCOUNT => 30));

ー顧客情報ー
-- ステップ1：購入履歴テーブルを一度まっさらにして作り直す
CREATE OR REPLACE TABLE TBL_PURCHASES (
    PURCHASE_ID       VARCHAR(10),
    CUSTOMER_ID       VARCHAR(10),
    PURCHASE_DATE     TIMESTAMP_NTZ,
    PRODUCT_CATEGORY  VARCHAR(50),
    PURCHASE_AMOUNT   NUMBER(10, 0),
    STORE_TYPE        VARCHAR(10)
);

-- ステップ2：作り直したテーブルに、40件の購入データを挿入する
INSERT INTO TBL_PURCHASES (
    PURCHASE_ID, CUSTOMER_ID, PURCHASE_DATE, PRODUCT_CATEGORY, PURCHASE_AMOUNT, STORE_TYPE
)
-- WITH句を使い、まず「購入者」を100人の会員の中からランダムに40人選出する
WITH PURCHASING_CUSTOMERS AS (
    SELECT 
        CUSTOMER_ID,
        CUSTOMER_RANK,
        AGE_GROUP
    FROM TBL_CUSTOMERS -- 既存の会員情報テーブルを参照
    ORDER BY RANDOM()
    LIMIT 40 -- 100人のうち、40人が購入したと仮定
)
-- 次に、選出された40人の購入データを生成する
SELECT
    'PURC' || LPAD(ROW_NUMBER() OVER (ORDER BY pc.CUSTOMER_ID), 5, '0'),
    pc.CUSTOMER_ID,
    -- 購入日は、2025年上半期のランダムな日時
    DATEADD(second, UNIFORM(0, 15552000, RANDOM()), '2025-01-01 00:00:00'),
    -- 商品カテゴリをランダムに割り振り
    DECODE(MOD(ABS(HASH(pc.CUSTOMER_ID)), 4),
        0, 'スナック菓子',
        1, 'チョコレート',
        2, '焼き菓子',
        'ドリンク'),
    -- 購入金額を、顧客ランクに応じて変動させる
    CASE
        WHEN pc.CUSTOMER_RANK = 'プラチナ' THEN UNIFORM(8000, 15000, RANDOM())
        WHEN pc.CUSTOMER_RANK = 'ゴールド' THEN UNIFORM(5000, 9000, RANDOM())
        WHEN pc.CUSTOMER_RANK = 'シルバー' THEN UNIFORM(2000, 6000, RANDOM())
        ELSE UNIFORM(500, 3000, RANDOM())
    END,
    -- 店舗種別をランダムに割り振り
    CASE WHEN UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) < 0.7 THEN 'EC' ELSE '実店舗' END
FROM
    PURCHASING_CUSTOMERS pc;

-アンケート結果-
-- ステップ1：テーブル（空の箱）を、ANSWER_ID列を「削除」して作り直す
CREATE OR REPLACE TABLE TBL_ANSWERS (
    CUSTOMER_ID       VARCHAR(10),
    CAMPAIGN_ID       VARCHAR(10),
    QUESTION_ID       VARCHAR(10),
    ANSWER_TEXT       VARCHAR(500),
    ANSWERED_AT       TIMESTAMP_NTZ
);

-- ステップ2：「Q1（参加キャンペーン）」の回答データだけを100件挿入する
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- WITH句を使い、まず「誰が、どのキャンペーンに参加したか」の対応表を作成
WITH 
-- 部品1: CUST00001からCUST00100までの、100人の回答者を生成
BASE_CUSTOMERS AS (
    SELECT
        'CUST' || LPAD(SEQ8(), 5, '0') as CUSTOMER_ID
    FROM TABLE(GENERATOR(ROWCOUNT => 100))
),
-- 部品2: 回答者と参加キャンペーンを紐付ける
RESPONDENTS AS (
    SELECT
        bc.CUSTOMER_ID,
        -- 顧客IDのハッシュ値を使い、参加キャンペーンに意図的な「偏り」を持たせる
        CASE 
            WHEN MOD(ABS(HASH(bc.CUSTOMER_ID)), 100) < 30 THEN 'CAMP00003' -- 30%はCAMP3に参加
            WHEN MOD(ABS(HASH(bc.CUSTOMER_ID)), 100) < 50 THEN 'CAMP00005' -- 20%はCAMP5に参加
            WHEN MOD(ABS(HASH(bc.CUSTOMER_ID)), 100) < 60 THEN 'CAMP00001' -- 10%はCAMP1に参加
            -- 残りの40%は、10件のキャンペーンの中からランダムに選ばれる
            ELSE 'CAMP' || LPAD(UNIFORM(1, 10, RANDOM()), 5, '0') 
        END AS CAMPAIGN_ID
    FROM BASE_CUSTOMERS bc
)
-- 最後に、その対応表と、キャンペーンマスターを「JOIN」で結合する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q1',
    -- JOINした結果から、キャンペーン名を安全に取得
    c.CAMPAIGN_NAME,
    -- ▼▼▼ 回答日時を、キャンペーン期間内のランダムな日時に修正 ▼▼▼
    DATEADD(
        second, 
        (DATEDIFF(second, c.START_DATE, c.END_DATE) * UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()))::INT, 
        c.START_DATE
    )
FROM 
    RESPONDENTS r
JOIN 
    TBL_CAMPAIGNS c ON r.CAMPAIGN_ID = c.CAMPAIGN_ID;

INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- まず、Q1に答えた全回答者のリストを、もう一度ここで定義する
WITH RESPONDENTS AS (
    SELECT DISTINCT CUSTOMER_ID, CAMPAIGN_ID, ANSWERED_AT 
    FROM TBL_ANSWERS 
    WHERE QUESTION_ID = 'Q1'
)
-- 次に、その回答者リストを基に、Q2の回答を生成する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q2',
    -- 回答の出現確率に、意図的な「偏り」を持たせる
    CASE 
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 35 THEN '新しさ・話題性'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 70 THEN '味の信頼性'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 90 THEN 'パッケージのデザイン'
        ELSE '価格の手頃さ'
    END,
    r.ANSWERED_AT
FROM RESPONDENTS r;

-- Q3の回答を100人分、生成して追記する
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- まず、Q1に答えた全回答者のリストを取得
WITH RESPONDENTS AS (
    SELECT DISTINCT CUSTOMER_ID, CAMPAIGN_ID, ANSWERED_AT 
    FROM TBL_ANSWERS 
    WHERE QUESTION_ID = 'Q1'
)
-- 次に、その回答者リストを基に、Q3の回答を生成する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q3',
    -- ▼▼▼ 回答の出現確率に、意図的な「偏り」を持たせる ▼▼▼
    CASE 
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 45 THEN 'Instagram'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 65 THEN 'X (旧Twitter)'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 85 THEN 'Web検索'
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 95 THEN 'メールマガジン'
        ELSE '店頭ポスター'
    END,
    r.ANSWERED_AT
FROM RESPONDENTS r;

-- Q4の回答を100人分、生成して追記する
INSERT INTO TBL_ANSWERS (CUSTOMER_ID, CAMPAIGN_ID, QUESTION_ID, ANSWER_TEXT, ANSWERED_AT)
-- まず、Q1に答えた全回答者のリストを取得
WITH RESPONDENTS AS (
    SELECT DISTINCT CUSTOMER_ID, CAMPAIGN_ID, ANSWERED_AT 
    FROM TBL_ANSWERS 
    WHERE QUESTION_ID = 'Q1'
)
-- 次に、その回答者リストを基に、Q4の回答を生成する
SELECT
    r.CUSTOMER_ID,
    r.CAMPAIGN_ID,
    'Q4',
    -- ▼▼▼ 顧客IDのハッシュ値を使い、意図した確率で、コメントの種類を決定 ▼▼▼
    CASE 
        -- 15%は「改善提案」
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 15 THEN 
            DECODE(MOD(ABS(HASH(r.CUSTOMER_ID)), 4),
                0, 'オンラインストアの決済方法を増やしてほしいです。後払い決済があると嬉しいです。',
                1, 'パッケージが少し開けにくいと感じました。ジッパー付きにするなど、改善していただけると嬉しいです。',
                2, 'Webサイトの応募方法が少し分かりにくかったです。もう少しシンプルな手順だと助かります。',
                '人気商品はすぐに売り切れてしまうので、もう少し在庫を増やしてほしいです。')
        -- 15%は「単なる批判・感想」
        WHEN MOD(ABS(HASH(r.CUSTOMER_ID)), 100) < 30 THEN
            DECODE(MOD(ABS(HASH(r.CUSTOMER_ID)), 4),
                0, '期待して購入しましたが、私には少し甘すぎると感じました。',
                1, '広告で見たイメージと、実物の色が少し違ったのが残念です。',
                2, '価格がもう少し安いと嬉しいです。',
                '届くまでに少し時間がかかったように思います。')
        -- 残りの70%は「ポジティブな感想」
        ELSE
            DECODE(MOD(ABS(HASH(r.CUSTOMER_ID)), 5),
                0, 'コラボデザインが想像以上に可愛く、つい全種類集めてしまいました。',
                1, '新商品、とても美味しかったです。また購入します。',
                2, 'キャンペーンありがとうございました。',
                3, '友人にもプレゼントしたら、とても喜ばれました。',
                '今後の企画も楽しみにしています！')
    END,
    r.ANSWERED_AT
FROM RESPONDENTS r;
